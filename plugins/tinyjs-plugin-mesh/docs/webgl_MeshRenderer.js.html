<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>webgl/MeshRenderer.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Tiny.mesh.Mesh.html">Mesh</a><ul class='methods'><li data-type='method'><a href="Tiny.mesh.Mesh.html#_calculateBounds">_calculateBounds</a></li><li data-type='method'><a href="Tiny.mesh.Mesh.html#_refresh">_refresh</a></li><li data-type='method'><a href="Tiny.mesh.Mesh.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Tiny.mesh.Mesh.html#multiplyUvs">multiplyUvs</a></li><li data-type='method'><a href="Tiny.mesh.Mesh.html#refresh">refresh</a></li></ul></li><li><a href="Tiny.mesh.NineSlicePlane.html">NineSlicePlane</a><ul class='methods'><li data-type='method'><a href="Tiny.mesh.NineSlicePlane.html#_calculateBounds">_calculateBounds</a></li><li data-type='method'><a href="Tiny.mesh.NineSlicePlane.html#_refresh">_refresh</a></li><li data-type='method'><a href="Tiny.mesh.NineSlicePlane.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Tiny.mesh.NineSlicePlane.html#multiplyUvs">multiplyUvs</a></li><li data-type='method'><a href="Tiny.mesh.NineSlicePlane.html#refresh">refresh</a></li><li data-type='method'><a href="Tiny.mesh.NineSlicePlane.html#updateHorizontalVertices">updateHorizontalVertices</a></li><li data-type='method'><a href="Tiny.mesh.NineSlicePlane.html#updateVerticalVertices">updateVerticalVertices</a></li></ul></li><li><a href="Tiny.mesh.Plane.html">Plane</a><ul class='methods'><li data-type='method'><a href="Tiny.mesh.Plane.html#_calculateBounds">_calculateBounds</a></li><li data-type='method'><a href="Tiny.mesh.Plane.html#_refresh">_refresh</a></li><li data-type='method'><a href="Tiny.mesh.Plane.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Tiny.mesh.Plane.html#multiplyUvs">multiplyUvs</a></li><li data-type='method'><a href="Tiny.mesh.Plane.html#refresh">refresh</a></li></ul></li><li><a href="Tiny.mesh.Rope.html">Rope</a><ul class='methods'><li data-type='method'><a href="Tiny.mesh.Rope.html#_calculateBounds">_calculateBounds</a></li><li data-type='method'><a href="Tiny.mesh.Rope.html#_refresh">_refresh</a></li><li data-type='method'><a href="Tiny.mesh.Rope.html#containsPoint">containsPoint</a></li><li data-type='method'><a href="Tiny.mesh.Rope.html#multiplyUvs">multiplyUvs</a></li><li data-type='method'><a href="Tiny.mesh.Rope.html#refresh">refresh</a></li><li data-type='method'><a href="Tiny.mesh.Rope.html#refreshVertices">refreshVertices</a></li></ul></li><li><a href="Tiny.MeshRenderer.html">MeshRenderer</a><ul class='methods'><li data-type='method'><a href="Tiny.MeshRenderer.html#render">render</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-Tiny.html">Tiny</a></li></ul><h3>Namespaces</h3><ul><li><a href="Tiny.mesh.html">mesh</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">webgl/MeshRenderer.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {default as Mesh} from '../Mesh';

const glCore = Tiny.glCore;
const matrixIdentity = Tiny.Matrix.IDENTITY;

/**
 * WebGL renderer plugin for tiling sprites
 *
 * @class
 * @memberof Tiny
 * @extends Tiny.ObjectRenderer
 */
class MeshRenderer extends Tiny.ObjectRenderer {

  /**
   * constructor for renderer
   *
   * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.
   */
  constructor(renderer) {
    super(renderer);

    this.shader = null;
  }

  /**
   * Sets up the renderer context and necessary buffers.
   *
   * @private
   */
  onContextChange() {
    const gl = this.renderer.gl;

    this.shader = new Tiny.Shader(gl,
      `
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
      `
varying vec2 vTextureCoord;
uniform float alpha;
uniform vec3 tint;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * vec4(tint * alpha, alpha);
}
      `);
  }

  /**
   * renders mesh
   *
   * @param {Tiny.mesh.Mesh} mesh mesh instance
   */
  render(mesh) {
    const renderer = this.renderer;
    const gl = renderer.gl;
    const texture = mesh._texture;

    if (!texture.valid) {
      return;
    }

    let glData = mesh._glDatas[renderer.CONTEXT_UID];

    if (!glData) {
      renderer.bindVao(null);

      glData = {
        shader: this.shader,
        vertexBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),
        uvBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW),
        indexBuffer: glCore.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),
        // build the vao object that will render..
        vao: null,
        dirty: mesh.dirty,
        indexDirty: mesh.indexDirty,
      };

      // build the vao object that will render..
      glData.vao = new glCore.VertexArrayObject(gl)
        .addIndex(glData.indexBuffer)
        .addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0)
        .addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);

      mesh._glDatas[renderer.CONTEXT_UID] = glData;
    }

    renderer.bindVao(glData.vao);

    if (mesh.dirty !== glData.dirty) {
      glData.dirty = mesh.dirty;
      glData.uvBuffer.upload(mesh.uvs);
    }

    if (mesh.indexDirty !== glData.indexDirty) {
      glData.indexDirty = mesh.indexDirty;
      glData.indexBuffer.upload(mesh.indices);
    }

    glData.vertexBuffer.upload(mesh.vertices);

    renderer.bindShader(glData.shader);

    glData.shader.uniforms.uSampler = renderer.bindTexture(texture);

    renderer.state.setBlendMode(mesh.blendMode);

    if (glData.shader.uniforms.uTransform) {
      if (mesh.uploadUvTransform) {
        glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true);
      } else {
        glData.shader.uniforms.uTransform = matrixIdentity.toArray(true);
      }
    }
    glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);
    glData.shader.uniforms.alpha = mesh.worldAlpha;
    glData.shader.uniforms.tint = mesh.tintRgb;

    const drawMode = mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;

    glData.vao.draw(drawMode, mesh.indices.length, 0);
  }
}

Tiny.WebGLRenderer.registerPlugin('mesh', MeshRenderer);

export default MeshRenderer;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri Aug 25 2017 12:43:49 GMT+0800 (CST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
